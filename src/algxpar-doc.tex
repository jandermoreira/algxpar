%! Author = Jander Moreira
%! Email =  moreira.jander@gmail.com
%! Date = 08/05/2023

\documentclass[a4paper, 11pt]{article}
\usepackage[T1]{fontenc}

\usepackage{tikz}
\usepackage{textcomp}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{makeidx}
\usepackage[all]{nowidow}

\usepackage[
    brazilian,
    language = english,
]{algxpar}


%% Layout

% geometry
\usepackage{geometry}
\geometry{top = 2.5cm, bottom = 2cm, right = 2.5cm, left = 4cm}

% hyperref
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    urlcolor = blue!20!black,
    linkcolor = blue!10!black,
    citecolor = black!80,
}

% cleveref
\usepackage{cleveref}

% makeidx
\usepackage{imakeidx}
\makeindex

% minted
\usepackage[outputdir = ../out]{minted}
\newminted{latex}{autogobble, breaklines, bgcolor = blue!5}
\newmintinline{latex}{}
%
% tcolorbox
\usepackage{tcolorbox}
\tcbuselibrary{skins, listings, minted, breakable}
\tcbset{
    colback = blue!3,
    sharp corners,
    box align = top,
    boxrule = 0pt,
    fontlower = \footnotesize,
    minted options={
        fontsize = \footnotesize,
        breaklines,
        autogobble,
    },
    listing engine = minted,
}

%% Text support

% macro arguments formats
\colorlet{argumentcolor}{orange!50!black}
\NewDocumentCommand{\Argument}{ m }{%
    \textcolor{argumentcolor}{$\langle$\normalfont\small\textsl{#1}$\rangle$}%
}
\NewDocumentCommand{\MArg}{ m }{\mbox{\texttt{\{}\Argument{#1}\texttt{\}}}}
\NewDocumentCommand{\OArg}{ m }{\mbox{\texttt{[}\Argument{#1}\texttt{]}}}
\NewDocumentCommand{\LArg}{ m }{\mbox{\texttt{<}\Argument{#1}\texttt{>}}}
\NewDocumentCommand{\PackageName}{ m }{\mbox{\textsf{#1}}}
\NewDocumentCommand{\Deprecated}{}{\textcolor{red!80!black}{(deprecated)}}
\NewDocumentCommand{\FromPackage}{ m }{%
    \tikz\node[draw, rounded corners = 1.5pt, inner sep = 1.5pt,
        font = \sffamily\tiny] {#1};%
}
\NewDocumentCommand{\Option}{ m }{\mbox{\texttt{#1}}}
\NewDocumentCommand{\OptionInd}{ m }{%
    \Option{#1}%
    \index{#1@\texttt{#1}~(option)}%
}
\NewDocumentCommand{\LatexMacro}{ m }{%
    \expandafter\latexinline\expandafter{\csname#1\endcsname}%
}
\NewDocumentCommand{\Macro}{ s m }{%
    \IfBooleanTF{#1}{%
        \LatexMacro{#2}%
    }{%
        \hyperref[macro:#2]{\LatexMacro{#2}}%
    }%
}
\NewDocumentCommand{\MacroInd}{ s m }{%
    \index{#2@\texttt{\textbackslash #2}}%
    \IfBooleanTF{#1}{%
        \label{macro:#2}%
        \Macro*{#2}%
    }{%
        \Macro{#2}%
    }%
}


% \newtcolorbox{codigo}[1]{%
%     bottomrule = 0pt,
%     toprule = 0pt,
%     leftrule = 0pt,
%     rightrule = 0pt,
%     titlerule = 0pt,
%     sharp corners,
%     sidebyside,
%     sidebyside align = top,
%     #1
% }


\NewDocumentEnvironment{macro}{ m O{} o }{%
    %! formatter = off
    \index{#1@\texttt{\textbackslash#1}}%
    \label{macro:#1}%
    %! parser = off
    \IfValueTF{#3}{%
        \begin{macro*}{#1}{#2}
    }{%
        \begin{macro*}{#1}{#2}[#3]%
    }
    %! parser = on
        }{%
    %! parser = off
    \end{macro*}
    %! parser = on
    %! formatter = on
}
\NewDocumentEnvironment{macro*}{ m m o }{
    \medskip\par%
    \begin{tcolorbox}[
        title = {\hspace{-2em}\Macro*{#1}#2\IfValueT{#3}{\latexinline!{#3} !}},
        coltitle = black,
        colbacktitle = white,
        titlerule = 0.001pt,
        enhanced jigsaw,
        breakable,
        width = \dimexpr \linewidth - 2em \relax,
        flush right,
        top = 0.5ex,
        bottom = 0pt,
        left = 0pt,
        right = 0pt,
        opacitybacktitle = 0,
        opacityframe = 0,
        opacityback = 0,
    ]
    }{
    \end{tcolorbox}
    \medskip%
}

%% Repetitive text
\NewDocumentCommand{\StatementOptions}{}{%
    Any \Argument{options} specified for this macro uniquely affect this statement.%
}
\NewDocumentCommand{\BlockOptions}{}{%
    Any of the \Argument{options} specified in this macro will affect this command and all items in the inner block, propagating up to and including the closing macro.%
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{The \PackageName{algxpar} package\thanks{This document corresponds to \PackageName{algxpar}~v\AlgVersion, dated \AlgDate.}}
\author{Jander Moreira\\\texttt{moreira.jander@gmail.com}}
\date{\today}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{document}
\maketitle
\sloppy

\begin{abstract}
    The \PackageName{algxpar} packages is an extension of the \PackageName{algorithmicx} package to handle multi-line text with the proper indentation.
\end{abstract}

\tableofcontents

\vspace{2em}

% \changes{v0.9}{2019/10/24}{First version}
% \changes{v0.91}{2020/04/30}{Macro now can be used as super-/subscripts in math formulas, while still preventing hyphenaton in text mode.}
% \changes{v0.91}{2020/06/14}{New macro for assignments, using $\gets$}
% \changes{v0.91}{2020/06/14}{New macro for assignments (verbose)}


\section{Introduction}
I teach algorithms and programming and have adopted the \PackageName{algorithmicx} package (\PackageName{algpseudocode}) to write my algorithms as it provides clear and easy-to-read pseudocodes with a minimum of effort to achieve visually pleasing code.

As part of the teaching process, I use very detailed commands in my algorithms before students start using a more synthetic form. For example, I initially write ``Start a counter $c$ with the value $0$'', which later becomes ``${c \gets 0}$''. This leads to sentences that often span text over two or more lines, especially in two-column documents with nested commands.

Unfortunately, \PackageName{algorithmx} doesn't natively support multi-line statements. This package therefore extends the macros to handle multiple lines properly. Some new commands and features were also added.


\section{Package usage and options}
To use the package simply add it to preamble.

\begin{macro*}{usepackage}{\OArg{package options list}}[algxpar]
    Currently, the package supports the following options:
    \begin{description}
        \item[\OptionInd{noend}] Suppresses the line that closes a block.
        \item[\Argument{language name}] Loads the keywords for an specific language. The lastest language in the list is set as default. Supported languages:
        \begin{itemize}
            \item \OptionInd{english} (default language, always loaded)
            \item \OptionInd{brazilian} Brazilian Portuguese
        \end{itemize}
        \item[\OptionInd{language}] Sets a language as default.
    \end{description}
\end{macro*}

Examples:
\begin{latexcode}
    \usepackage[noend]{algxpar} %  Supresses all "end lines"

    \usepackage[brazilian]{algxpar} %  Loads Brazilian keyword set and sets it as default

    \usepackage[brazilian, language = english]{algxpar}  % Loads Brazilian keywords but keeps english as default
\end{latexcode}


\section{Writting pseudocode}
All pseudocode is written inside the \texttt{algorithmic} environment.

\subsection{How comments and options are handled}
Until \PackageName{algxpar} v0.95, comment text was added as an optional argument before the text of a given command. For example:

%! formatter = off
\begin{tcblisting}{}
    \begin{algorithmic}
        \Statep{Get first $k$}
        \While[loop though all $k$]{$k$ is valid}
            \Statep[do some work]{\Call{Process}{$k$}}
            \Statep{Get next $k$}
        \EndWhile
    \end{algorithmic}
\end{tcblisting}
%! formatter = on

Using the comment before the text bothered me a lot as it seemed more natural to have it after. As of v0.99, the comment can be placed after the text, making writing more user-friendly.

To maintain backward compatibility, using comments before the text is still supported, although its use is discouraged.

%! formatter = off
\begin{tcblisting}{}
    \begin{algorithmic}
        \Statep{Get first $k$}
        \While{$k$ is valid}[loop though all $k$]
            \Statep{\Call{Process}{$k$}}[do some work]
            \Statep{Get next $k$}
        \EndWhile
    \end{algorithmic}
\end{tcblisting}
%! formatter = on

In this section, comments in the old style are indicated as \Argument{comment*}, while the new format uses \Argument{comment}.

In addition to this change, block end specifications (like \Macro{EndWhile}, for example) also accept the new form of comments. This new approach will, however, make it unfeasible to use local comments with \Macro{Comment} after the closing block macro. See \cref{sec:comments}.

\begin{tcblisting}{}
    \begin{algorithmic}
        \While{\textit{condition}}
            [tested \textbf{before}]
            \Statep{Some command}
        \EndWhile[bottom of the loop]
    \end{algorithmic}
\end{tcblisting}

A list of options can be added to each command by locally changing some algorithm presentation settings. These settings are optional and must be entered using angle brackets at the end of the command.

%! formatter = off
\begin{tcblisting}{}
    \begin{algorithmic}
        \If{$a > b$}
            \While{$a > 0$}<keyword color = blue!70>
                \Statep{\Call{Process}{$a$}}
            \EndWhile
        \EndIf
    \end{algorithmic}
\end{tcblisting}
%! formatter = on

\subsection{Documentation}
A series of macros are defined to provide the header documentation for a pseudocode. The basics are:
\begin{macro}{Description}
    [~\Argument{text}]
    The \Macro*{Description} is intended to hold the general description of the pseudocode.
\end{macro}

\begin{macro}{Require}
    [~\Argument{text}]
    The required initial state that the code relies on. These are \textit{pre-conditions}.
\end{macro}

\begin{macro}{Ensure}
    [~\Argument{text}]
    The final state produced by the code. These are \textit{post-conditions}.
\end{macro}

\begin{tcblisting}{}
    \begin{algorithmic}
        \Description Calculation of the factorial of a natural number through successive multiplications
        \Require $n \in \mathbb{N}$
        \Ensure $f = n!$
    \end{algorithmic}
\end{tcblisting}

Also are provided:
\begin{macro}{Input}
    [~\Argument{text}]
    Inputs.
\end{macro}
\begin{macro}{Output}
    [~\Argument{text}]
    Outputs
\end{macro}

\begin{tcblisting}{}
    \begin{algorithmic}
        \Description Calculation of the factorial of a natural number through successive multiplications
        \Input $n$ (integer)
        \Output $n!$ (integer)
    \end{algorithmic}
\end{tcblisting}

\subsection{Constants and Identifiers}

Constants: \MacroInd{True} is \True, \MacroInd{False} is \False\ and \MacroInd{Nil} is \Nil.

\begin{macro}{Id}[\MArg{identifier}]
    Identifiers are in italics: \latexinline!\Id{value}! is \Id{value}. Its designed to work in both text and math modes: \latexinline!$\Id{offer}_k$! is $\Id{offer}_k$.
\end{macro}

\subsection{Statements}

The macros \MacroInd*{State} and \MacroInd*{Statex} can still be used and were left unchanged. A replacement to macro \Macro*{State} is \Macro*{Statep}.

\begin{macro}{Statep}[\MArg{text}\OArg{comment}\LArg{options}]
\end{macro}

\begin{tcblisting}{}
    \begin{minipage}{6cm}
        \begin{algorithmic}
            \State Collect all relevant information from the selected databases
            \State Process all data\Comment{in parallel}
            \State Present a report with the results and send to management
        \end{algorithmic}

        \bigskip
        \begin{algorithmic}
            \Statep{Collect all relevant information from the selected databases}
            \Statep{Process all data}[in parallel]
            \Statep{Present a report with the results and send to management}
        \end{algorithmic}
    \end{minipage}
\end{tcblisting}

\subsection{Assignments and I/O}

To support teaching-like pseudocode writing, the macros \MacroInd*{Read} and \MacroInd*{Write} are provided.

\begin{tcblisting}{}
    \begin{algorithmic}
        \Statep{\Read $v_1, v_2$}
        \Statep{$\Id{mean} \gets \dfrac{v_1 + v_2}{2}$}[calculate]
        \Statep{\Write \Id{mean}}
    \end{algorithmic}
\end{tcblisting}

The macro \Macro*{Set} can be used for assignments.

\begin{macro}{Set}[\MArg{lvalue}\MArg{expression} \Deprecated]
    This macro expands to \Macro{Id}\latexinline!{#1} \gets #2!.

    As the handling of text and math modes should be done and its usage brings no evident advantage, this macro will no longer be supported. It will be kept as is for backward compatibility however.
\end{macro}

\subsection{Comments}\label{sec:comments}
The \Macro*{Comment} macro defined by \PackageName{algorithmicx} has the same original behavior and has been redefined to handle styling options. It can be used, however, only within the text argument of some command. See more information about this at the end of this section.

\begin{macro}{Comment}[\MArg{text}\LArg{options}]
    The redesigned version of \Macro*{Comment} can be used with \Macro{State}, \Macro{Statex} and \Macro{Statep}. When used with \Macro{Statep}, it must be enclosed inside the text braces, but multi-line statements should work differently than expected.

    \StatementOptions
\end{macro}

\begin{tcblisting}{sidebyside = false}
    \begin{minipage}{6.5cm}
        \AlgSet{comment color = blue}%  for viewing purposes only
        \begin{algorithmic}
            \State Store the value zero in variable $x$\Comment{just zeroes $x$}
            \Statep{Store the value zero in variable $x$\Comment{just zeroes $x$}}
            \Statep{Store the value zero in variable $x$}[just zeroes $x$]% best choice
        \end{algorithmic}
    \end{minipage}
\end{tcblisting}

\begin{macro}{Commentl}[\MArg{text}\LArg{options}]
    While \Macro{Comment} pushes text to the end of the line, the macro \Macro*{Commentl} is ``local''. In other words, it just put a comment in place.

    Local comments follows regular text and no line changes are checked.

    \StatementOptions
\end{macro}

\begin{tcblisting}{}
    \begin{algorithmic}
        \If{$a > 0$~~\Commentl{special case}\\
        or\\
            $a < b$~~\Commentl{general case}\\}
            \Statep{Process data~~\Commentl{may take a while}}
        \EndIf
    \end{algorithmic}
\end{tcblisting}

To incorporate multi-line handling while maintaining a consistent visual appearance, none of these macros can be used outside the text of a given command.

\begin{tcblisting}{}
    % This worked fine with package algorithmicx
    % Now it is broken...
    \begin{algorithmic}
        \If{$a > b$}
            \Comment{simple test}
            \Statep{$b \gets a$}
        \EndIf
    \end{algorithmic}
\end{tcblisting}

\subsection{Flow Control}
The macro \Macro*{If} stands for the \Keyword{if}/\Keyword{then}/\Keyword{else} conditional.

\begin{macro}{If}[\OArg{comment*}\MArg{text}\OArg{comment}\LArg{options}]
    In its simpler form, \Macro*{If} shows \Argument{text} (the condition) and must be closed with an \Macro{EndIf}, creating a block of nested commands.

    \BlockOptions
\end{macro}

\begin{macro}{EndIf}[\OArg{comment}\LArg{options}]
    \Macro*{EndIf} closes its respective \Macro{If}.

    \StatementOptions
\end{macro}

\begin{tcblisting}{}
    \begin{algorithmic}
        \State \Read $v$
        \If{$v < 0$}[is it negative?]
            \Statep{$v \gets -v$}[make it positive]
        \EndIf
    \end{algorithmic}
\end{tcblisting}

The macros \Macro*{Else} and \Macro*{ElsIf} are also available.

\begin{macro}{Else}[\OArg{comment}\LArg{options}]
    This macro defines the \Keyword{else} part of the \Macro{If} statement.

    \BlockOptions
\end{macro}

\begin{macro}{Elsif}[\OArg{comment*}\MArg{text}\OArg{comment}\LArg{options}]
    \Macro*{ElsIf} defines the \Keyword{if} chaining. The argument \Argument{text} is the new condition.

    \BlockOptions
\end{macro}

A selection-like conditional statement was added: \Macro*{Switch}. A \Keyword{switch} evaluates an expression and compares successively with a number of \Keyword{case} clauses.

\begin{macro}{Switch}[\OArg{comment*}\MArg{expression}\OArg{comment}\LArg{options}]
    The \Macro*{Switch} is closed by a matching \Macro{EndSwitch}.

    \BlockOptions
\end{macro}

\begin{macro}{EndSwitch}[\OArg{comment}\LArg{options}]
    This macro closes a \Macro{Switch} block.

    \StatementOptions
\end{macro}

\begin{macro}{Case}[\OArg{comment*}\MArg{constant-list}\OArg{comment}\LArg{options}]
    When the result of the \Keyword{switch} expression matches one of the constants in \Argument{constants-list}, then the \Keyword{case} is executed. Usually the \Argument{constant-list} is a single constant, a comma-separated list of constants or some kind of range specification.

    \BlockOptions
\end{macro}

\begin{macro}{EndCase}[\OArg{comment}\LArg{options}]
    This macro closes a corresponding \Macro{Case} statement.

    \StatementOptions
\end{macro}

\begin{macro}{Otherwise}[\OArg{comment}\LArg{options}]
    A \Keyword{switch} structure can optionally use an \Keyword{otherwise} clause, which is executed when no previous \Keyword{case}s had a hit.

    \BlockOptions
\end{macro}

\begin{macro}{EndOtherwise}[\OArg{comment}\LArg{options}]
    This macro closes a corresponding \Macro{Otherwise} statement.

    \StatementOptions
\end{macro}

%! formatter = off
\begin{tcblisting}{}
    \begin{algorithmic}
        \Statep{Get \Id{option}}
        \Switch{\Id{option}}
            \Case{1}[inserts new record]
                \Statep{\Call{Insert}{\Id{record}}}
            \EndCase
            \Case{2}[deletes a record]
                \Statep{\Call{Delete}{\Id{key}}}
            \EndCase
            \Otherwise
                \Statep{Print ``invalid option''}
            \EndOtherwise
        \EndSwitch
    \end{algorithmic}
\end{tcblisting}
%! formatter = on

The classic loops are defined: \Keyword{for}, \Keyword{while} and \Keyword{repeat}.

The \Keyword{for} loop uses \Macro*{For} and is also flavored with two variants: \Keyword{foreach} (\Macro*{ForEach}) and \Keyword{forall} (\Macro*{ForAll}).

\begin{macro}{For}[\OArg{comment*}\MArg{text}\OArg{comment}\LArg{options}]
    The \Argument{text} is used to establish the loop scope.

    A comment can be added to the command both as \Argument{comment*} and \Argument{comment}.

    \BlockOptions
\end{macro}

\begin{macro}{EndFor}[\OArg{comment}\LArg{option}]
    This macro closes a corresponding \Macro{For}, \Macro{ForEach} or \Macro{ForAll}.

    \StatementOptions
\end{macro}

\begin{macro}{ForEach}[\OArg{comment*}\MArg{text}\OArg{comment}\LArg{options}]
    Same as \Macro{For}.
\end{macro}

\begin{macro}{ForAll}[\OArg{comment*}\MArg{text}\OArg{comment}\LArg{options}]
    Same as \Macro{For}.
\end{macro}

%! parser = off
\begin{tcblisting}{}
    \begin{algorithmic}
        \For{$i \gets 0$ \To $n$}
            \Statep{Do something with $i$}
        \EndFor
        \ForAll{$\Id{item} \in C$}
            \Statep{Do something with \Id{item}}
        \EndFor
        \ForEach{\Id{item} in queue $Q$}
            \Statep{Do something with \Id{item}}
        \EndFor
    \end{algorithmic}
\end{tcblisting}
%! parser = on

The loop with testing at the top is \Macro*{While}.

\begin{macro}{While}[\OArg{comment*}\MArg{text}\OArg{comment}\LArg{options}]
    In \Argument{text} is the boolean expression that, when \False, will end the loop.

    \BlockOptions
\end{macro}

\begin{macro}{EndWhile}[\OArg{comment}\LArg{options}]
    This macro closes a matching \Macro{While} block.

    \StatementOptions
\end{macro}

\begin{tcblisting}{}
    \begin{algorithmic}
        \While{$n > 0$}
            \Statep{Do something}
            \Statep{$n \gets n - 1$}
        \EndWhile
    \end{algorithmic}
\end{tcblisting}

\begin{macro}{Repeat}[\OArg{comment}\LArg{options}]
    This macro starts the \Keyword{repeat} loop, which is closed with \Macro{Until}.

    \BlockOptions
\end{macro}

\begin{macro}{Until}[\OArg{comment*}\MArg{text}\OArg{comment}\LArg{options}]
    In \Argument{text} is the boolean expression that, when \True, will end the loop.

    \StatementOptions
\end{macro}


\begin{tcblisting}{}
    \begin{algorithmic}
        \Repeat
            \Statep{Do something}
            \Statep{$n \gets n - 1$}
        \Until{$n \leq 0$}
    \end{algorithmic}
\end{tcblisting}


An additional generic loop is build with \Macro*{Loop}.

\begin{macro}{Loop}[\OArg{comment}\LArg{options}]
    The generic loop starts with \Macro*{Loop} and ends with \Macro{EndLoop}. Usually the infinit loop is interrupted by and internal \MacroInd{Break} or restarted with \MacroInd{Continue}.

    \BlockOptions
\end{macro}

\begin{macro}{EndLoop}[\OArg{comment}\LArg{options}]
    \Macro*{EndLoop} closes a matching \Macro{Loop} block.

    \StatementOptions
\end{macro}

\begin{tcblisting}{}
    \begin{algorithmic}
        \Loop
            \Statep{Do something}
            \Statep{$n \gets n + 1$}
            \If{$n$ is multiple of 5}
                \Statep{\Continue}[restarts loop]
            \EndIf
            \Statep{Do something else}
            \If{$n \leq 0$}
                \Statep{\Break}[ends loop]
            \EndIf
        \EndLoop
    \end{algorithmic}
\end{tcblisting}

\subsection{Procedures and Functions}


\section{Customization and Fine Tunning}

\begin{macro}{Keyword}[\OArg{language}\MArg{keyword}]
    Macros like \Macro*{algorithmicwhile} from \PackageName{algorithimicx} where replaced with \Macro{Keyword}, using \latexinline{\Keyword{while}} or \latexinline{\Keyword[brazilian]{while}}, for example.
    If \Argument{language} is not specified, the current language is used. \Argument{keyword} is any keyword defined for a language, including custom ones.

    Section~\ref{sec:languages-and-translations} shows the predefined keywords.

    \begin{tcblisting}{}
        In English, the ``for all'' loop uses \Keyword{forall}, while it is \Keyword[brazilian]{forall} in Brazilian Portuguese.
    \end{tcblisting}
\end{macro}

\begin{macro}{SetKeyword}[\OArg{language}\MArg{keyword}\MArg{value}]
    The macro \Macro{SetKeyword} changes a given \Argument{keyword} to \Argument{value} if it exists; otherwise new keyword is created.
    If \Argument{language} is not specified, then the current language is affected. Changes are local if the macro is used inside a group.
\end{macro}


\section{Languages and translations}\label{sec:languages-and-translations}


\tcbinputlisting{listing file = brazilian.kw.tex, listing only}




\clearpage
\printindex

\end{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%