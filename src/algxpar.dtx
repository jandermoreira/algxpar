% \iffalse
%<*driver>
\ProvidesFile{algxpar.dtx}
\documentclass{ltxdoc}
\usepackage[english]{babel}

\usepackage{xcolor}
\usepackage{fancyvrb}
\usepackage{tcolorbox}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\tcbuselibrary{listings, skins, xparse, breakable}
\newenvironment{commands}{
	\VerbatimEnvironment
	\begin{tcolorbox}[
		bottomrule = 0pt,
		toprule = 0pt,
		leftrule = 0pt,
		rightrule = 0pt,
		titlerule = 0pt,
		colframe = white,
		colback = white,
		sharp corners,
		pad at break*=1pc,
		enhanced jigsaw,
		overlay first and middle={
			\coordinate (A1) at ($(interior.south east) + (-10pt,5pt)$);
			\coordinate (C1) at ($(interior.south east) + (-6pt,7.5pt)$);
			\draw[fill=tcbcolframe] (A1) -- +(0,5pt) -- (C1) -- cycle;
		},
	]%
	\begin{Verbatim}[gobble = 2, tabsize=4, commandchars = &\[\]]%
}{%
	\end{Verbatim}%
	\end{tcolorbox}%
}
\newtcolorbox{codigo}[1]{%
	bottomrule = 0pt,
	toprule = 0pt,
	leftrule = 0pt,
	rightrule = 0pt,
	titlerule = 0pt,
	sharp corners,
	sidebyside,
	sidebyside align = top,
	#1
}
\newcommand{\afile}[1]{\mbox{\texttt{#1}}}
\newcommand{\package}[1]{\mbox{\textsf{#1}}}
\newcommand{\inlinecommand}[1]{\mbox{\texttt{#1}}}

\usetikzlibrary{calc}
\newenvironment{example}{
	\begingroup\tcbverbatimwrite{\jobname_code.tmp}
}{
	\endtcbverbatimwrite\endgroup%
	\begin{tcolorbox}[
			bottomrule = 0pt,
			toprule = 0pt,
			leftrule = 0pt,
			rightrule = 0pt,
			titlerule = 0pt,
			colframe = white,
			segmentation style = {black!30, solid},
			colback = white,
			sharp corners,
			pad at break*=1pc,
			enhanced jigsaw,
			breakable,
			overlay first and middle={
				\coordinate (A1) at ($(interior.south east) + (-10pt,5pt)$);
				\coordinate (C1) at ($(interior.south east) + (-6pt,7.5pt)$);
				\draw[fill=tcbcolframe] (A1) -- +(0,5pt) -- (C1) -- cycle;
			},
		]%
	\small\VerbatimInput[tabsize=4, gobble = 2]{\jobname_code.tmp}
	\tcblower
% 	\begin{minipage}{0.85\linewidth}
	\begin{algorithmic}
		\input{\jobname_code.tmp}
	\end{algorithmic}
% 	\end{minipage}
	\end{tcolorbox}
}

\usepackage[backref=page]{hyperref}
\hypersetup{
	colorlinks,
	urlcolor = blue!20!black,
	linkcolor = blue!10!black,
	citecolor = black!80,
}

\usepackage{algxpar}

\usepackage{imakeidx}
\makeindex

\EnableCrossrefs
% \CodelineIndex
% \PageIndex
\RecordChanges
\begin{document}
	\sloppy
	\DocInput{algxpar.dtx}
\end{document}
%</driver>
% \fi
%
% \let\DM\DescribeMacro
% \makeatletter
% \def\cstostr#1{%
% 	\expandafter\@gobble\detokenize\expandafter{\string#1}}
% \makeatother
% \renewcommand{\DescribeMacro}[1]{%
% 	\DM{#1}%
% }
%
% \CheckSum{0}
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
%
% \changes{v0.9}{2019/10/24}{Initial version}
%
% \GetFileInfo{algxpar.sty}
%
%
% \DoNotIndex{\newcommand,\newenvironment,\renewcommand,\renewenvironment}
% \DoNotIndex{\#,\$,\%,\&,\@,\\,\{,\},\^,\_,\~,\ }
% \DoNotIndex{\@ne}
% \DoNotIndex{\advance,\begingroup,\catcode,\closein}
% \DoNotIndex{\closeout,\day,\def,\edef,\else,\empty,\endgroup}
% \DoNotIndex{\def,\dimexpr,\parbox,\relax,\else,\fi,\hfill}
% \DoNotIndex{\setlength,\settowidth,\strut,\ifdim,\ifx}
% \DoNotIndex{\linewidth,\temp,\theALG@nested}
% \DoNotIndex{\\}
% \DoNotIndex{\RaggedRight}
%
%
% \title{The \package{algxpar} package\thanks{This document
%   corresponds to \package{algxpar}~\fileversion, dated \filedate.}}
% \author{Jander Moreira\\\texttt{moreira.jander@gmail.com}}
%
% \maketitle
% %
% \begin{abstract}
% 	The \textsf{algxpar} packages is an extension of the \textsf{algorithmicx} package to handle multiline text with the proper indentation.
% \end{abstract}
%
% \tableofcontents
%
% \PrintChanges
%
% \section{Introduction}
% I teach algorithms and programming and adopted the \package{algorithmicx} package (\package{algpseudocode}) to typeset my code, as it provides a clean, easy to read pseudolanguage algorithms with a minimum effort to write.
%
% As part of the teaching process, I use very verbose commands in my algorithms before the students start to use more sintetic text. For example, I use ``\textit{Iniciate a counter $c$ with the value $0$}'', what will become ``${c \gets 0}$'' later. This leads to sentences that often span the text for multiple lines, specially in two-column documents with nested structures.
%
% Unfortunatelly, \package{algorithmicx} has no support for multiline statements natively, but it can adapted to use |\parbox|es to achive this goal.
%
% This package, therefore, extends macros to handle multiple lines in a seamlessly way. Some new commands and features are also added.
%
% \section{Instalation}
% The package \package{algxpar} is provided by the files \afile{algxpar.ins} and \afile{algxpar.dtx}.
%
% If the \afile{.sty} file is not available, it can be generated by running the following at a command line prompt.
%
% \begin{commands}
% latex algxpar.ins
% \end{commands}
%
%  Then the generated \afile{algxpar.sty} must be copied to a directory searched by \LaTeX. Package dependencies can be checked in section~\ref{sec:implementation}.
%
%
% \section{Usage}
% The package must be loaded using
% \begin{commands}
% \usepackage&oarg[options]{algxpar}
% \end{commands}
%
% The only option to the package is |brazilian|, which sets the pseudocode ``reserved words'' to Brazilian Portuguese, so |\While| is rendered \textbf{enquanto} instead of \textbf{while}, for example. No other language is supported so far, but a translation can be easily achieved (see section~\ref{sec:customization}).
%
%
% \section{Writing pseudocode}
% The algorithms must be written using the |algorithmic| environment and use basically the same set of macros defined by \package{algpseudcode}.
%
% \begin{commands}
% \begin{algorithmic}
%     &ensuremath[&langle]&textrm[&textit[contents]]&ensuremath[&rangle]
% \end{algorithmic}
% \end{commands}
%
% \subsubsection*{Example}
% Consider the following code.
%
% \begin{commands}
% \begin{algorithmic}
% \Function{Max}{$a, b$}
% 	\If{$a > b$}
% 		\Statep{\Return $a$}
% 	\Else
% 		\Statep{\Return $b$}
% 	\EndIf
% \EndFunction
% \end{algorithmic}
% \end{commands}
%
% The corresponding typeset is shown below.
%
% \begin{algorithmic}
% \Function{Max}{$a, b$}
% 	\If{$a > b$}
% 		\Statep{\Return $a$}
% 	\Else
% 		\Statep{\Return $b$}
% 	\EndIf
% \EndFunction
% \end{algorithmic}
%
%
% \subsection{Header}
% A header for the algorithm is proposed so the algorithm can provide a description, its inputs and outputs, as well as the preconditions and post-conditions Therefore, new macros are defined.
%
% \DescribeMacro{\Description}
%	A description can be provided for the sake of code documentation. The macro |\Description| is used to provide such a text.
% \DescribeMacro{\Input}
% \DescribeMacro{\Output}
%	The input requirements for the algorithm uses the clause |\Input| and the produced by the code should be expressed with |\Output|.
% \DescribeMacro{\Require}
% \DescribeMacro{\Ensure}
% Also, the possibility to use |\Require| and |\Ensure| remains.
%
% \subsubsection*{Examples}
%
% \begin{example}
% \Description Evaluates and prints the factorial of $n$
% \Input A non-negative integer number $n$
% \Output The value of the factorial $n$\end{example}
%
% \begin{example}
% \Require $n \in \{1, 2, \ldots, 10\}$
% \Ensure $k = \max(1, 2, \ldots, 10)$\end{example}
%
%
% \subsection{Constants and identifiers}
% \DescribeMacro{\True}
% \DescribeMacro{\False}
% \DescribeMacro{\Nil}
% Some additional macros were added: |\True|, |\False|, and |\Nil|, producing \True, \False, and \Nil, respectively.
%
% \DescribeMacro{\Id}
% The macro |\Id|\marg{id} was included to support long variable names, such as \Id{maxval} or \Id{count}, for example. This macro handles better ligatures and accented characters than the regular math mode. |$offered$| results in $offered$ and |\Id{offered}| produces \Id{offered}. With accented characters, |$magnético$| and |\Id{magnético}| result in $magnético$ and \Id{magnético}, respectively.
%
% \DescribeMacro{\TextString}
% For literal constants, usually represented quoted in programs and algorithms, the macro |\TextString|\marg{text} is provided, so |\TextString{Error}| produces \TextString{Error}.
%
% \DescribeMacro{\VisibleSpace}
% An additional macro called |\VisibleSpace| is also provided to produce \VisibleSpace. Sometimes the number of spaces is relevant in text strings, so one can write |\TextString{a\VisibleSpace\VisibleSpace\VisibleSpace b}| to get \TextString{a\VisibleSpace\VisibleSpace\VisibleSpace b}.
%
% The macros |\Id| and |\TextString| work in text and math modes.
%
% \subsection{Assignment, reading and writing}
% \DescribeMacro{\gets}
% The default symbol for assigning values to variables is $\gets$, provided by |\gets|. This is a clearer option, once the equal sign is left just for comparisons.
%
% \DescribeMacro{\Read}
% \DescribeMacro{\Write}
% Although not common in algorithms published in scientific journals, explicit reading and writing is necessary for basic algorithms. Therefore |\Read| and |\Write| fulfills this need.
%
% \begin{example}
% \Statep{\Read\ $a, b$}
% \Statep{$s \gets a + b$}
% \Statep{\Write\ $s$}\end{example}
%
% \DescribeMacro{\Set}
% \DescribeMacro{\Setl}
% Besides |\gets|, the macros |\Set| and |\Setl| can be used for assignments.
%
% |\Set|\marg{id}\marg{value} is a shortcut to |\Id{id} \gets value|. The ``long'' version for the assigment is |\Setl|\marg{id}\marg{value}, to get the verbose ``\algorithmicset\ \Id{id} \algorithmicsetto\ \Id{value}''.
%
% \subsection{Comments}
% Comments use the symbol \makeatletter\axp@commentleftsymbol\makeatother\ preceding the commented text and stay close to the left margin. Comment macros are intended to be used with |\State| or |\Statex|, when no multiline handling is done. Comments with multiline control are considered starting at section~\ref{sec:statements}.
%
% \DescribeMacro{\Comment}
% The macro |\Comment|\marg{text} puts \meta{text} at the end of the line.
%
% \DescribeMacro{\Commentl}
% A variant, |\Commentl|\marg{text}, places the commented text without moving it to the left margin. It is a ``local'' comment.
%
% \DescribeMacro{\CommentIn}
% A third option is |\CommentIn|\marg{text}, that places the comment locally, but finishes it with \makeatletter\axp@commentrightsymbol\makeatother. Yes, that is really ugly.
%
% \begin{example}
% \State\Commentl{Simple counter}
% \State $c \gets 1$\Comment{initialize conter}
% \State $n \gets \Call{FirstInstance}{}$
% \While{$n < 0$}
% 	\State $c \gets c + 1$\Comment{counts one more}
% 	\State $n \gets \mbox{\CommentIn{all new} } \Call{NewInstance}{}$
% \EndWhile
% \end{example}
%
% \subsection{Statements}\label{sec:statements}%
% \DescribeMacro{\Statep}
% \DescribeMacro{\State}
% \DescribeMacro{\Statex}
% The statements should use |\Statep|\marg{text}, which defines a hang indent for continued lines. The \package{algorithmicx}'s  |\State| and |\Statex| can be used as well.
%
% In opposition to |\State| and |\Statex|, which uses justified text, |\Statep| aligns only to the left, what is aesthetically better than justification in my opinion.
%
% Since |\Statep| uses a |\parbox| to span the text over multiple lines, no room is left for a comment. When needed a comment can be added through the optional argument: |\Statep|\oarg{comment}\marg{text}.
%
% \subsubsection*{Example}
% \begin{example}
% \Statep{Calculate the value of $x$ using $k$ and $m$,
%	 considering the stochastic distribution}
% \Statep[$k \neq 0$, $m > k$]{Calculate the value of $x$
%	using $k$ and $m$, considering the stochastic distribution}\end{example}
%
% \subsection{Conditionals}
% The traditional \textbf{if}-\textbf{then}-\textbf{else} structure is suported, handling nested commands as well.
% An \textbf{else~if} construction avoids nesting \textbf{if}s and getting too much indentation. The macros are: |\If|, |\Else|, and |\ElsIf|.
%
% \DescribeMacro{\If}
% \DescribeMacro{\Else}
% |\If|\oarg{comment}\marg{condition} is used for conditional execution and is ended with a |\EndIf|. The optional \meta{comment} is typeset to the left and the \meta{condition} is put in a |\parbox|. Regular |\Comment| and |\Commentl| can be used after |\Else|.
%
% \DescribeMacro{\ElsIf}
% The \textbf{else~if} clause is specified by |\ElsIf|\oarg{comment}\marg{condition}.
%
% \DescribeMacro{\Switch}
% \DescribeMacro{\EndSwitch}
% \DescribeMacro{\Case}
% \DescribeMacro{\EndCase}
% \DescribeMacro{\Otherwise}
% \DescribeMacro{\EndOtherwise}
% Flow control using a selection structure are provided by the macro |\Switch|\oarg{comment}\marg{selector}, ended with |\EndSwitch|. Each matching clause uses |\Case|\oarg{comment}\marg{value} and |\EndCase|. The default uses |\Otherwise| and |\EndOtherwise|.
%
% To specify ranges, the macro |\Range|\oarg{step}\marg{start}\marg{end} can be used. For example, |\Range{1}{10}| outputs \Range{1}{10} and |\Range[2]{0}{10}| prints \Range[2]{0}{10}.
%
% \subsubsection*{Examples}
%
% \begin{example}
% \If{$a < 0$}
% 	\Statep{$a \gets 0$}
% \EndIf\end{example}
%
% \begin{example}
% \If[closing doors]{the building is empty and the
%   security system is active}
% 	\Statep{$\Id{status} \gets \TextString{ok}$}
% \Else
% 	\Statep{$\Id{status} \gets \TextString{not ok}$}
% \EndIf\end{example}
%
% \begin{example}
% \If[desired status]{$n \geq 0.8$}
% 	\Statep{$\Id{status} \gets \TextString{excelent}$}
% \ElsIf{$n \geq 0.7$}
% 	\Statep{$\Id{status} \gets \TextString{great}$}
% \ElsIf{$n \geq 0.5$}
% 	\Statep{$\Id{status} \gets \TextString{good}$}
% \ElsIf{$n \geq 0.2$}
% 	\Statep{$\Id{status} \gets \TextString{not so good}$}
% \Else\Comment{minimum not achieved}
% 	\Statep{$\Id{status} \gets \TextString{call for help}$}
% \EndIf\end{example}
%
% \begin{example}
% \Switch[$1 \leq \Id{month} \leq 12$]{\Id{month}}
%     \Case{2}
%         \If{\Call{IsLeapYear}{\Id{year}}}
%             \Statep{$n_{days} \gets 29$}
%         \Else
%             \Statep{$n_{days} \gets 28$}
%         \EndIf
%     \EndCase
%     \Case{4, 6, 9, 11}
%         \Statep{$n_{days} \gets 30$}
%     \EndCase
%     \Otherwise\Comment{1, 3, 5, 7, 8, 10, 12}
%         \Statep{$n_{days} \gets 31$}
%     \EndOtherwise
% \EndSwitch\end{example}
%
% \subsection{Loops}
% Loops uses \textbf{while}, \textbf{repeat~until}, and \textbf{for} flow control.
%
% \DescribeMacro{\While}
% \DescribeMacro{\EndWhile}
% Loops with condition on top uses |\While|\oarg{comment}\marg{condition} and are ended with |\EndWhile|.
%
% \DescribeMacro{\Repeat}
% \DescribeMacro{\Until}
% When loops have their termination condition tested at the bottom, the macros |\Repeat| and |\Until|\oarg{comment}\marg{condition} are used.
%
% \DescribeMacro{\For}
% \DescribeMacro{\ForAll}
% \DescribeMacro{\ForEach}
% The \textbf{for} loop starts with |\For|\oarg{comment}\marg{condition} and ends with |\EndFor|. To make things more versatile, |\For| can be replaced by |\ForAll| or |\ForEach|.
%
% \DescribeMacro{\To}
% \DescribeMacro{\DownTo}
% \DescribeMacro{\Step}
% Some macros for supporting loops are also provided: |\To|, |\DownTo|, and |\Step|, which defaults to \To, \DownTo, and \Step, repectively.
%
% \subsection*{Examples}
% \begin{example}
% \While{there is data in the input stream and no
%     termination signal was received}
%     \Statep{Get element $e$ from the input stream}
%     \Statep{\Call{Process}{$e$}}
% \EndWhile\end{example}
%
% \begin{example}
% \Statep[$n_1, n_2 > 0$]{Let $n_1$ and $n_2$
% be the two integers in order to find the greatest
% number that divides both}
% \Repeat
%   \Statep[$n_1 \bmod n_2$]{Set \Id{rest} as the
%	      rest of the integer
%	      division of $n_1$ by $n_2$}
%   \Statep{Redefine $n_1$ with the value of $n_2$}
%   \Statep{Redefine $n_2$ with the value of \Id{rest}}
% \Until[terminates]{$\Id{rest} = 0$}
% \Statep[greatest common divisor]{Set $m$ to the value of $n_1$}\end{example}
%
% \begin{example}
% \For{$i \gets n-1$ \DownTo\ $0$}
%   \Statep{$s \gets s + i$}
% \EndFor\end{example}
%
% \begin{example}
% \ForEach[main transactions]{transaction $t$ in the flow
%     of transactions for month $m$}
%     \Statep{\Call{ProcessTransaction}{$t$}}
% \EndFor\end{example}
%
% \begin{example}
% \ForAll{$e$ in set $M$}
%     \Statep{\Call{ProcessElement}{$e$}}
% \EndFor\end{example}
%
% \subsection{Procedures and functions}
% \DescribeMacro{\Procedure}
% \DescribeMacro{\EndProcedure}
% \DescribeMacro{\Function}
% \DescribeMacro{\EndFunction}
% \DescribeMacro{\Return}
% Procedure and functions are supported with |\Procedure|\marg{name}\marg{arguments} and |\EndProcedure| and |\Function|\marg{name}\marg{arguments} and |\EndFunction|. The return value for functions uses |\Return|.
%
% \subsection*{Examples}
% \begin{example}
% \Procedure{PrintError}{$code$}
%     \Switch{$code$}
%         \Case{1}
%             \Statep{\Write\ \TextString{Not found}}
%         \EndCase
%         \Case{2}
%             \Statep{\Write\ \TextString{Access denied}}
%         \EndCase
%         \Case{3}
%             \Statep{\Write\ \TextString{Blocked}}
%         \EndCase
%         \Otherwise
%             \Statep{\Write\ \TextString{Unknown}}
%         \EndOtherwise
%     \EndSwitch
% \EndProcedure\end{example}
%
% \begin{example}
% \Function{CelsiusToFahrenheit}{$t$}
%     \Statep{\Return $\dfrac{9}{5}t + 32$}
% \EndFunction\end{example}
%
% \begin{example}
% \Function[many parameters]{MyFunction}
%    {$a$, $b$, $c$, $d$, $e$, $f$, $g$, $h$, $i$, $j$, $k$, $l$}
%     \Statep{\Return $\dfrac{a+b+c+d}{f+g+hi^{j}}kl$}
% \EndFunction\end{example}
% %
% \section{Extras}
% Sometimes just letting the |\parbox| handle the line breaks is not enough.
% \DescribeMacro{\NewLine}
% The macro |\NewLine| can be used to manually break lines.
%
% \DescribeEnv{DefineCode}
% \DescribeMacro{\UseCode}
% \DescribeMacro{\ShowCode}
% It is possible to define pieces of code for later use. Using the environment |DefineCode| with a \meta{name}, a part of the pseudocode can be specified and used with |\UseCode|\marg{name}. The \meta{name} provided should be unique; when repeated the code is overwritten. The macro |\ShowCode|\oarg{options}\marg{name} displays the saved code \textit{verbatim}. Any option for |\VerbatimInput| from \package{fancyvrb} can be specified in \meta{options}. All chuncks of code are written to temporary files.
%
%
% \subsection*{Examples}
%
% \begin{example}
% \If{$h > 0$ and\NewLine
% 		($n_1 \neq 0$ or $n_2 < n_1$) and \NewLine
% 		$p \neq \Nil$}
% 	\Statep{\Call{DoSomething}{}}
% \Else
% 	\Statep{\Call{DoSomethingElse}{}}
% \EndIf
% \end{example}
%
% \begin{DefineCode}{half_in_out}
% \Input A number $n$
% \Output Half of $n$ (i.e., $n/2$)
% \end{DefineCode}
% \begin{DefineCode}{half_code}
% \Statep[in]{Get $n$}
% \Statep[out]{Print $n/2$}
% \end{DefineCode}
%
% \begin{minipage}{\linewidth}
% \small
% \begin{Verbatim}[gobble = 2, tabsize = 4]
% \begin{DefineCode}{half_in_out}
% 	\Input A number $n$
% 	\Output Half of $n$ (i.e., $n/2$)
% \end{DefineCode}
% \begin{DefineCode}{half_code}
% 	\Statep[in]{Get $n$}
% 	\Statep[out]{Print $n/2$}
% \end{DefineCode}
% \end{Verbatim}
% \end{minipage}
%
% \vspace{\baselineskip}Inside |algorithmic| one can use the following definitions.
% \begin{example}
% \UseCode{half_in_out}
% \Statep{\Commentl{Code}}
% \UseCode{half_code}
% \end{example}
%
% The source is shown by |\ShowCode{half_code}|.
% \ShowCode[gobble = 2]{half_code}
%
% \StopEventually{}
%
%
% \section{Implementation}\label{sec:implementation}%
% This package is \package{algxpar}~\fileversion~--~\LaTeXe.
% \vspace{\baselineskip}
%    \begin{macrocode}
\NeedsTeXFormat{LaTeX2e}[2005/12/01]
\ProvidesPackage{algxpar}
	[2020/05/30 v0.91 Algorithms with multiline/paragraph support]
%    \end{macrocode}

% \iffalse
%% Package options
% \fi
%    \begin{macrocode}
\newif\ifaxp@brazilian\axp@brazilianfalse
\DeclareOption{brazilian}{\axp@braziliantrue}
\DeclareOption*{\PackageWarning{algxpar}{Unknown ‘\CurrentOption’}}
\ProcessOptions\relax
%    \end{macrocode}

% \iffalse
%% Required packages
% \fi
% \package{ragged2e}: for |\RaggedRight|\par
% \package{listings}: to get accented characters in verbatim mode (pt\_BR)\par
% \package{amsmath}, amssymb: for |\triangleright| and |\triangleleft|\par
% \package{xcolor}: gray color for |\VisibleSpace|\par
% \package{tcolorbox}: verbatim save to file\par
% \package{fancyvrb}: verbatim read from file with tabs\par
%    \begin{macrocode}
\RequirePackage{algorithmicx}
\RequirePackage{algpseudocode}
\RequirePackage{ragged2e}
\RequirePackage{listings}
\RequirePackage{amsmath, amssymb}
\RequirePackage{xcolor}
\RequirePackage{tcolorbox} % to save verbatim
\RequirePackage{fancyvrb} % to load verbatim preserving tabs
%    \end{macrocode}

% \iffalse
%% Constants and identifiers
% \fi
% \begin{macro}{\True}
% \begin{macro}{\False}
% \begin{macro}{\Nil}
% \begin{macro}{\Id}
% \changes{v0.91}{2020/04/30}{Macro now can be used as super-/subscripts in math formulas, while still preventing hyphenaton in text mode.}
% \begin{macro}{\TextString}
% \begin{macro}{\VisibleSpace}
%    \begin{macrocode}
\algnewcommand\algorithmictrue{True}
\algnewcommand\algorithmicfalse{False}
\algnewcommand\algorithmicnil{Nil}
\algnewcommand\True{\ensuremath{\textsc{\rmfamily \algorithmictrue}}}
\algnewcommand\False{\ensuremath{\textsc{\rmfamily \algorithmicfalse}}}
\algnewcommand\Nil{\ensuremath{\textsc{\rmfamily \algorithmicnil}}}
\newcommand{\Id}[1]{\ensuremath{\textit{\rmfamily#1}}}
\newcommand{\TextString}[1]{\textrm{\normalfont``{\ttfamily\mbox{#1}}''}}
\algnewcommand{\VisibleSpace}{\textrm{\color{black!70}\textvisiblespace}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}

% \iffalse
%% Headings
% \fi
% \begin{macro}{\Description}
% \begin{macro}{\Input}
% \begin{macro}{\Output}
% \begin{macro}{\Ensure}
% \begin{macro}{\Require}
%    \begin{macrocode}
\algnewcommand\algorithmicdescription{\textbf{Description}}
\algnewcommand\algorithmicinput{\textbf{Input}}
\algnewcommand\algorithmicoutput{\textbf{Output}}
\algrenewcommand\algorithmicensure{\textbf{Ensure}}
\algrenewcommand\algorithmicrequire{\textbf{Require}}
\algnewcommand\Description{\item[\algorithmicdescription:]}
\algnewcommand\Input{\item[\algorithmicinput:]}
\algnewcommand\Output{\item[\algorithmicoutput:]}
\algrenewcommand\Ensure{\item[\algorithmicensure:]}
\algrenewcommand\Require{\item[\algorithmicrequire:]}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}

% \iffalse
%% Read, write
% \fi
% \begin{macro}{\Read}
% \begin{macro}{\Write}
% \begin{macro}{\Set}
% \changes{v0.91}{2020/06/14}{New macro for assignments, using $\gets$}
% \begin{macro}{\Setl}
% \changes{v0.91}{2020/06/14}{New macro for assignments (verbose)}
%    \begin{macrocode}
\algnewcommand{\algorithmicread}{\textbf{read}}
\algnewcommand{\algorithmicwrite}{\textbf{write}}
\algnewcommand\algorithmicset{Set}
\algnewcommand\algorithmicsetto{to}
\algnewcommand{\Set}[2]{\Id{#1} $\gets$ #2}
\algnewcommand{\Setl}[2]{\algorithmicset\ #1 \algorithmicsetto\ #2}
\algnewcommand{\Read}{\algorithmicread}
\algnewcommand{\Write}{\algorithmicwrite}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}

% \iffalse
%% Comments
% \fi
% \begin{macro}{\Comment}
% \begin{macro}{\Commentl}
% \begin{macro}{\CommentIn}
%    \begin{macrocode}
\newcommand{\axp@commentleftsymbol}{$\triangleright$}
\newcommand{\axp@commentrightsymbol}{$\triangleleft$}
\algnewcommand{\CommentIn}[1]{\axp@commentleftsymbol~%
  \textsl{#1}~\axp@commentrightsymbol}
\algnewcommand{\Commentl}[1]{\axp@commentleftsymbol~\textsl{#1}}
\algrenewcommand{\algorithmiccomment}[1]{%
	\def\tmp{#1}%
	\ifx\tmp\empty\else%
	\hfill\Commentl{#1}%
	\fi
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%

% \iffalse
%% Statep
% \fi
% \begin{macro}{\Statep}
%    \begin{macrocode}
\newlength{\axp@stateindent}
\setlength{\axp@stateindent}{\dimexpr\algorithmicindent/2\relax}
\algnewcommand{\Statep}[2][]{\State\algparbox[#1]{#2}{\axp@stateindent}}
%    \end{macrocode}
%\end{macro}

% \iffalse
%% While
% \fi
% \begin{macro}{\While}
% \begin{macro}{\EndWhile}
%    \begin{macrocode}
\newlength{\axp@whilewidth}
\algblockdefx{While}{EndWhile}%
	[2][]{%
		\settowidth{\axp@whilewidth}{\algorithmicwhile\ }%
		\algparbox[#1]{\algorithmicwhile\ #2~\algorithmicdo}{\axp@whilewidth}%
	}%
	{\algorithmicend\ \algorithmicwhile}
%    \end{macrocode}
% \end{macro}
% \end{macro}

% \iffalse
%% Repeat
% \fi
% \begin{macro}{\Repeat}
% \begin{macro}{\Until}
%    \begin{macrocode}
\newlength{\axp@untilwidth}
\algblockdefx{Repeat}{Until}%
	{\algorithmicrepeat}%
	[2][]{%
		\settowidth{\axp@untilwidth}{\algorithmicuntil\ }%
		\axp@algparbox{#1}{\algorithmicuntil\ #2}{\axp@untilwidth}{0}%
	}
%    \end{macrocode}
% \end{macro}
% \end{macro}

% \iffalse
%% If, else if, else
% \fi
% \begin{macro}{\If}
% \begin{macro}{\Else}
% \begin{macro}{\ElsIf}
% \begin{macro}{\EndIf}
%    \begin{macrocode}
\newlength{\axp@ifwidth}
\newlength{\axp@elseifwidth}
\algblockdefx[If]{If}{EndIf}%
	[2][]{%
		\settowidth{\axp@ifwidth}{\algorithmicif\ }%
		\algparbox[#1]{\algorithmicif\ #2~\algorithmicthen}{\axp@ifwidth}%
	}
	{\algorithmicend\ \algorithmicif}
\algcblockx[If]{If}{ElsIf}{EndIf}
	[2][]{%
		\settowidth{\axp@elseifwidth}{\algorithmicelse\ \algorithmicif\ }%
		\algparbox[#1]{\algorithmicelse~\algorithmicif\ #2~\algorithmicthen}{\axp@elseifwidth}%
	}
	{\algorithmicend\ \algorithmicif}
\algcblockx{If}{Else}{EndIf}
	{\textbf{\algorithmicelse}}
	{\textbf{\algorithmicend~\algorithmicif}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}

% \iffalse
%% Switch, case, otherwise
% \fi
% \begin{macro}{\Switch}
% \begin{macro}{\EndSwitch}
% \begin{macro}{\Case}
% \begin{macro}{\EndCase}
% \begin{macro}{\Otherwise}
% \begin{macro}{\EndOtherwise}
% \begin{macro}{\Range}
%    \begin{macrocode}
\algnewcommand{\algorithmicswitch}{\textbf{switch}}
\algnewcommand{\algorithmicof}{\textbf{of}}
\algnewcommand{\algorithmiccase}{\textbf{case}}
\algnewcommand{\algorithmicotherwise}{\textbf{otherwise}}
\newlength{\axp@switchwidth}
\algblockdefx{Switch}{EndSwitch}%
	[2][]{%
		\settowidth{\axp@switchwidth}{\algorithmicswitch\ }%
		\algparbox[#1]{\algorithmicswitch\ #2~\algorithmicof}{\axp@switchwidth}%
	}
	{\algorithmicend~\algorithmicswitch}
\newlength{\axp@casewidth}
\algblockdefx{Case}{EndCase}%
	[2][]{%
		\settowidth{\axp@casewidth}{\algorithmiccase\ }%
		\algparbox[#1]{\algorithmiccase\ #2~\algorithmicdo}{\axp@casewidth}%
	}
	{\algorithmicend~\algorithmiccase}
\algblockdefx{Otherwise}{EndOtherwise}%
	{\algorithmicotherwise~\algorithmicdo}%
	{\textbf{\algorithmicend\ \algorithmicotherwise}}
\newcommand{\Range}[3][]{%
	\ensuremath{%
		#2%
		\def\temp{#1}%
		\mathcal{\ldotp\ldotp}#3
		\ifx\temp\empty\relax\else{\ensuremath{\mathcal{:}#1}}\fi%
	}%
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}

% \iffalse
%% For, for each, for all
% \fi
% \begin{macro}{\For}
% \begin{macro}{\ForEch}
% \begin{macro}{\ForAll}
% \begin{macro}{\EndFor}
% \begin{macro}{\To}
% \begin{macro}{\DownTo}
% \begin{macro}{\Step}
%    \begin{macrocode}
\algnewcommand{\To}{\textbf{to}}
\algnewcommand{\DownTo}{\textbf{downto}}
\algnewcommand{\Step}{\textbf{step}}
\newlength{\axp@forwidth}
\algblockdefx{For}{EndFor}%
	[2][]{%
		\settowidth{\axp@forwidth}{\algorithmicfor\ }%
		\algparbox[#1]{\algorithmicfor\ #2~\algorithmicdo}{\axp@forwidth}%
	}
	{\algorithmicend\ \algorithmicfor}
\algnewcommand{\algorithmicforeach}{\textbf{for~each}}
\newlength{\axp@foreachwidth}
\algblockdefx{ForEach}{EndFor}%
	[2][]{%
		\settowidth{\axp@foreachwidth}{\algorithmicforeach\ }%
		\algparbox[#1]{\algorithmicforeach\ #2~\algorithmicdo}{\axp@foreachwidth}%
	}
	{\algorithmicend\~\algorithmicfor}
\newlength{\axp@forallwidth}
\algblockdefx{ForAll}{EndFor}%
	[2][]{%
		\settowidth{\axp@forallwidth}{\algorithmicforall\ }%
		\algparbox[#1]{\algorithmicforall\ #2~\algorithmicdo}{\axp@forallwidth}%
	}%
	{\algorithmicend\ \algorithmicfor}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}

% \iffalse
%% Procedure, function, calls
% \fi
% \begin{macro}{\Procedure}
% \begin{macro}{\EndProcedure}
% \begin{macro}{\Function}
% \begin{macro}{\EndFunction}
% \begin{macro}{\Call}
%    \begin{macrocode}
\newlength{\axp@procedurewidth}
\newlength{\axp@namewidth}
\algblockdefx{Procedure}{EndProcedure}%
	[3][]{%
		\settowidth{\axp@procedurewidth}{\algorithmicprocedure~}%
		\settowidth{\axp@namewidth}{\textsc{#2}(}%
		\addtolength{\axp@procedurewidth}{0.6\axp@namewidth}%
		\algparbox[#1]{\algorithmicprocedure\ \textsc{#2}(#3)}{\axp@procedurewidth}
	}%
	{\algorithmicend\ \algorithmicprocedure}
\newlength{\axp@functionwidth}
\algblockdefx{Function}{EndFunction}%
	[3][]{%
		\settowidth{\axp@functionwidth}{\algorithmicfunction~}%
		\settowidth{\axp@namewidth}{\textsc{#2}(}%
		\addtolength{\axp@functionwidth}{0.6\axp@namewidth}%
		\algparbox[#1]{\algorithmicfunction\ \textsc{#2}(#3)}{\axp@functionwidth}
	}%
	{\algorithmicend\ \algorithmicfunction}
\algrenewcommand\Call[2]{%
	\def\argstmp{#2}%
	\textsc{#1}\ifx\argstmp\empty\mbox{(\hskip0.5ex)}\else(#2)\fi%
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}

% \iffalse
%% NewLine
% \fi
% \begin{macro}{\NewLine}
%    \begin{macrocode}
\newcommand{\NewLine}{\\}
%    \end{macrocode}
% \end{macro}

% \iffalse
%% DefineCode, UseCode, \ShowCode
% \fi
% \begin{environment}{DefineCode}
% \begin{macro}{\UseCode}
% \begin{macro}{\ShowCode}
%    \begin{macrocode}
\newenvironment{DefineCode}[1]
{\begingroup\tcbverbatimwrite{\jobname_code_#1.tmp}}
{\endtcbverbatimwrite\endgroup}
\newcommand{\UseCode}[1]{\input{\jobname_code_#1.tmp}}
\newcommand{\ShowCode}[2][]{{\small\VerbatimInput[tabsize=4, #1]%
		{\jobname_code_#2.tmp}}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{environment}

% \changes{v0.91}{2020/04/30}{Small fix in the position of the triangle in line numbers.}
% \begin{macro}{\alglinenumber}
%    \begin{macrocode}
\algrenewcommand{\alglinenumber}[1]%
  {\hspace{-1.5em}\color{black!35}{\scriptsize#1}\raisebox{0.2ex}{\tiny$\blacktriangleright$}}
%    \end{macrocode}
% \end{macro}

% \iffalse
%% axp@algparbox
% \fi
% \begin{macro}{\axp@algparbox}
%    \begin{macrocode}
\newlength{\axp@commentwidth}
\setlength{\axp@commentwidth}{0pt}
\newcommand{\algparbox}[3][]{\axp@algparbox{#1}{#2}{#3}{1}}

\newlength{\axp@largestcommentwidth}
\setlength{\axp@largestcommentwidth}{0.3\linewidth}
\newcommand{\axp@algparbox}[4]{%
    \def\temp{#1}%
    \ifx\temp\empty%
        \setlength{\axp@commentwidth}{-2em}%
    \else%
        \settowidth{\axp@commentwidth}{\axp@commentleftsymbol\ #1}%
        \ifdim\axp@commentwidth>\axp@largestcommentwidth\relax%
            \setlength{\axp@commentwidth}{\axp@largestcommentwidth}%
        \fi%
    \fi%
    \renewcommand{\NewLine}{\\\hspace{#3}}%
    \parbox[t]{\dimexpr\linewidth-\axp@commentwidth-%
        (\algorithmicindent)*(\theALG@nested - #4)-2em}%
        {\RaggedRight\setlength{\hangindent}{#3}#2\strut}%
    \ifx\temp\empty\else%
        \hfill\axp@commentleftsymbol\hspace{0.5em}%
        \parbox[t]{\axp@commentwidth}{\slshape\RaggedRight#1}%
    \fi%
    \renewcommand{\NewLine}{\\}%
}
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
\lstset{
	literate=
		{á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
		{Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
		{à}{{\`a}}1 {è}{{\`e}}1 {ì}{{\`i}}1 {ò}{{\`o}}1 {ù}{{\`u}}1
		{À}{{\`A}}1 {È}{{\'E}}1 {Ì}{{\`I}}1 {Ò}{{\`O}}1 {Ù}{{\`U}}1
		{ä}{{\"a}}1 {ë}{{\"e}}1 {ï}{{\"i}}1 {ö}{{\"o}}1 {ü}{{\"u}}1
		{ã}{{\~a}}1 {õ}{{\~o}}1
		{Ã}{{\~A}}1 {Õ}{{\~O}}1
		{Ä}{{\"A}}1 {Ë}{{\"E}}1 {Ï}{{\"I}}1 {Ö}{{\"O}}1 {Ü}{{\"U}}1
		{â}{{\^a}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1
		{Â}{{\^A}}1 {Ê}{{\^E}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1 {Û}{{\^U}}1
		{ç}{{\c c}}1 {Ç}{{\c C}}1
		{ø}{{\o}}1 {å}{{\r a}}1 {Å}{{\r A}}1
		{œ}{{\oe}}1 {Œ}{{\OE}}1 {æ}{{\ae}}1 {Æ}{{\AE}}1
		{ß}{{\ss}}1
		{ű}{{\H{u}}}1 {Ű}{{\H{U}}}1 {ő}{{\H{o}}}1 {Ő}{{\H{O}}}1
		{£}{{\pounds}}1
		{«}{{\guillemotleft}}1
		{»}{{\guillemotright}}1
		{ñ}{{\~n}}1 {Ñ}{{\~N}}1 {¿}{{?`}}1
}
%    \end{macrocode}

%
% \section{Customization}\label{sec:customization}%
% By default, the longest width for a comment at the right margin is
%|0.3\linewidth|. This can be changed using something like the code below.
%
% \begin{commands}
% \makeatletter
% \setlength{\axp@largestcommentwidth}{&meta[new length]}
% \makeatother
% \end{commands}
%
% The assignment sign can be changed from $\gets$ to anything else, as well as the symbols used in comments.
%
% \begin{commands}
% \renewcommand{\gets}{\mathop{::=}}
% \renewcommand{\axp@commentleftsymbol}{\texttt{//}}
% \renewcommand{\axp@commentrightsymbol}{\texttt{*/}}
% \end{commands}
%
% To handle languages, the macro |\algxparset| should be used.
%
%    \begin{macrocode}
\pgfkeys{
	algxpar/.cd,
	brazilian/.code = {\axp@languagebrazilian},
	english/.code = {\axp@languageenglish},
	default/.code = {\axp@languageenglish},
}
\newcommand{\algxparset}[1]{
	\pgfkeys{
		algxpar/.cd,
		#1
	}
}
\newcommand{\axp@languagebrazilian}{
	\algrenewcommand\algorithmicdescription{\textbf{Descrição}}
	\algrenewcommand\algorithmicinput{\textbf{Entrada}}
	\algrenewcommand\algorithmicoutput{\textbf{Saída}}
	\algrenewcommand\algorithmicrequire{\textbf{Pré}}
	\algrenewcommand\algorithmicensure{\textbf{Pós}}
	\algrenewcommand{\algorithmicend}{\textbf{fim}}
	\algrenewcommand{\algorithmicif}{\textbf{se}}
	\algrenewcommand{\algorithmicthen}{\textbf{então}}
	\algrenewcommand{\algorithmicelse}{\textbf{senão}}
	\algrenewcommand{\algorithmicswitch}{\textbf{escolha}}
	\algrenewcommand{\algorithmicof}{\textbf{de}}
	\algrenewcommand{\algorithmiccase}{\textbf{caso}}
	\algrenewcommand{\algorithmicotherwise}{\textbf{caso~contrário}}
	\algrenewcommand{\algorithmicfor}{\textbf{para}}
	\algrenewcommand{\algorithmicdo}{\textbf{faça}}
	\algrenewcommand{\algorithmicwhile}{\textbf{enquanto}}
	\algrenewcommand{\algorithmicrepeat}{\textbf{repita}}
	\algrenewcommand{\algorithmicuntil}{\textbf{até que}}
	\algrenewcommand{\algorithmicloop}{\textbf{repita}}
	\algrenewcommand{\algorithmicforeach}{\textbf{para~cada}}
	\algrenewcommand{\algorithmicforall}{\textbf{para~todo}}
	\algrenewcommand{\algorithmicfunction}{\textbf{função}}
	\algrenewcommand{\algorithmicprocedure}{\textbf{procedimento}}
	\algrenewcommand{\algorithmicreturn}{\textbf{retorne}}
	\algrenewcommand{\algorithmictrue}{Verdadeiro}
	\algrenewcommand{\algorithmicfalse}{Falso}
	\algrenewcommand{\algorithmicnil}{Nulo}
	\algrenewcommand{\algorithmicread}{\textbf{leia}}
	\algrenewcommand{\algorithmicwrite}{\textbf{escreva}}
	\algrenewcommand{\algorithmicset}{Defina}
	\algrenewcommand{\algorithmicsetto}{como}
	\algrenewcommand{\To}{\textbf{até}}
	\algrenewcommand{\DownTo}{\textbf{decrescente~até}}
	\algrenewcommand{\Step}{\textbf{passo}}
}
\newcommand{\axp@languageenglish}{
	\algrenewcommand\algorithmicdescription{\textbf{Description}}
	\algrenewcommand\algorithmicinput{\textbf{Input}}
	\algrenewcommand\algorithmicoutput{\textbf{Output}}
	\algrenewcommand\algorithmicrequire{\textbf{Pre}}
	\algrenewcommand\algorithmicensure{\textbf{Post}}
	\algrenewcommand{\algorithmicend}{\textbf{end}}
	\algrenewcommand{\algorithmicif}{\textbf{if}}
	\algrenewcommand{\algorithmicthen}{\textbf{then}}
	\algrenewcommand{\algorithmicelse}{\textbf{else}}
	\algrenewcommand{\algorithmicswitch}{\textbf{swith}}
	\algrenewcommand{\algorithmicof}{\textbf{of}}
	\algrenewcommand{\algorithmiccase}{\textbf{case}}
	\algrenewcommand{\algorithmicotherwise}{\textbf{otherwise}}
	\algrenewcommand{\algorithmicfor}{\textbf{for}}
	\algrenewcommand{\algorithmicdo}{\textbf{do}}
	\algrenewcommand{\algorithmicwhile}{\textbf{while}}
	\algrenewcommand{\algorithmicrepeat}{\textbf{repeat}}
	\algrenewcommand{\algorithmicuntil}{\textbf{until}}
	\algrenewcommand{\algorithmicloop}{\textbf{loop}}
	\algrenewcommand{\algorithmicforeach}{\textbf{for~each}}
	\algrenewcommand{\algorithmicforall}{\textbf{for~all}}
	\algrenewcommand{\algorithmicfunction}{\textbf{function}}
	\algrenewcommand{\algorithmicprocedure}{\textbf{procedure}}
	\algrenewcommand{\algorithmicreturn}{\textbf{return}}
	\algrenewcommand{\algorithmictrue}{True}
	\algrenewcommand{\algorithmicfalse}{False}
	\algrenewcommand{\algorithmicnil}{Nil}
	\algrenewcommand{\algorithmicread}{\textbf{read}}
	\algrenewcommand{\algorithmicwrite}{\textbf{write}}
	\algrenewcommand{\algorithmicset}{Set}
	\algrenewcommand{\algorithmicsetto}{to}
	\algrenewcommand{\To}{\textbf{to}}
	\algrenewcommand{\DownTo}{\textbf{downto}}
	\algrenewcommand{\Step}{\textbf{step}}
}
\axp@languageenglish % default language
\ifaxp@brazilian\algxparset{brazilian}\fi
%    \end{macrocode}
%
% \section{To do\ldots}
% There are lots of improvements to make in the code. I recognize it!
%
% \section*{Appendix}
% \appendix
%\section{An example}
% \newcommand*{\Leaf}{\mbox{\textsc{Leaf}}}
% \newcommand*{\Internal}{\mbox{\textsc{Internal}}}
% \newcommand*{\InvalidItem}{\mbox{\textsc{InvalidItem}}}
%
% \begin{example}
% 	\Description Inserts a new item in the B-tree structure,
% 		handling only the root node
% 	\Input The \Id{item} to be inserted
% 	\Output Returns \True\ in case of success, \False\ in
% 		case of failure (i.e., duplicated keys)
% 	\Function{Insert}{\Id{item}}
% 		\If{\Id{tree.root address} is \Nil}
% 			\Statep{\Commentl{Create first node}}
% 			\Statep[\Nil\ = new node]{$\Id{new root node}
% 				\gets \Call{GetNode}{\Nil}$}
% 			\Statep[only item]{Insert \Id{item} in \Id{new
% 				root node} and set both  its left and right
% 				childs to \Nil; also set \Id{new root
% 				node.count} to 1}
% 			\Statep[first node is always a leaf]{Set \Id{new
% 				root node.type} to \Leaf}
% 			\Statep[flag that node must be updated in file]
% 				{Set \Id{new root node.modified} to \True}
% 			\Statep{\Call{WriteNode}{\Id{new root node}}}
% 			\Statep{$\Id{tree.root address} \gets
% 				\Id{new root node.address}$}
% 			\Statep[update root address in file]
% 				{\Call{WriteRootAddress}{}}
% 			\Statep{\Return \True}
% 		\Else
% 			\Statep{\Commentl{Insert in existing tree}}
% 			\Statep[]{$\Id{success}$,
% 			$\Id{promoted item}$, $\Id{new node address} \gets
% 				\Call{SearchInsert}{\Id{tree.root address},
% 				\Id{item}}$}
% 			\If[root has splitted]{\Id{success} and
% 				${\Id{new node address}\neq\Nil}$}
% 				\Statep[new root]{$\Id{new root node} \gets
% 					\Call{GetNode}{\Nil}$}
% 				\Statep{Insert \Id{promoted item} in \Id{new
% 					root node} and set \Id{new root node.count}
% 					to 1}
% 				\Statep[tree height grows]{Set \Id{item}'s
% 					left child to \Id{tree.root
% 					address} and right child to \Id{new
% 					node address}}
% 				\Statep[not a leaf]{Set \Id{new root
% 						node.type} to \Internal}
% 				\Statep{Set \Id{new root node.modified}
% 					to \True}
% 				\Statep{\Call{WriteNode}{\Id{new root
% 					node}}}
% 				\Statep{$\Id{tree.root address} \gets
% 					\Id{new root node.address}$}
% 				\Statep[update root address in
% 					file]{\Call{WriteRootAddress}{}}
% 			\EndIf
% 			\Statep[insertion status]{\Return \Id{success}}
% 		\EndIf
% 	\EndFunction
% \end{example}
%
% \clearpage\PrintIndex
%
% \Finale
\endinput